{"version":3,"sources":["../src/renderer.js"],"names":["PromiseIpcRenderer","opts","maxTimeoutMs","route","dataArgs","Promise","resolve","reject","replyChannel","timeout","didTimeOut","ipcRenderer","once","event","status","returnData","clearTimeout","Error","send","setTimeout","listener","on","then","results","catch","e","removeAllListeners","PromiseIpc","mainExport","module","exports"],"mappings":";;;;;;;qjBAAwC;;;AAAxC;;AACA;;;;AACA;;;;AACA;;;;;;;;IAEaA,kB,WAAAA,kB;AACX,8BAAYC,IAAZ,EAAkB;AAAA;;AAChB,QAAIA,IAAJ,EAAU;AACR,WAAKC,YAAL,GAAoBD,KAAKC,YAAzB;AACD;AACF;;;;yBAEIC,K,EAAoB;AAAA;;AAAA,wCAAVC,QAAU;AAAVA,gBAAU;AAAA;;AACvB,aAAO,IAAIC,kBAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,YAAMC,eAAkBL,KAAlB,SAA2B,kBAAjC;AACA,YAAIM,gBAAJ;AACA,YAAIC,aAAa,KAAjB;;AAEA;AACAC,8BAAYC,IAAZ,CAAiBJ,YAAjB,EAA+B,UAACK,KAAD,EAAQC,MAAR,EAAgBC,UAAhB,EAA+B;AAC5DC,uBAAaP,OAAb;AACA,cAAIC,UAAJ,EAAgB;AACd,mBAAO,IAAP;AACD;AACD,kBAAQI,MAAR;AACE,iBAAK,SAAL;AACE,qBAAOR,QAAQS,UAAR,CAAP;AACF,iBAAK,SAAL;AACE,qBAAOR,OAAOQ,UAAP,CAAP;AACF;AACE,qBAAOR,OAAO,IAAIU,KAAJ,kCAAyCH,MAAzC,aAAuDX,KAAvD,CAAP,CAAP;AANJ;AAQD,SAbD;AAcAQ,8BAAYO,IAAZ,+BAAiBf,KAAjB,EAAwBK,YAAxB,SAAyCJ,QAAzC;;AAEA,YAAI,MAAKF,YAAT,EAAuB;AACrBO,oBAAUU,WAAW,YAAM;AACzBT,yBAAa,IAAb;AACAH,mBAAO,IAAIU,KAAJ,CAAad,KAAb,iBAAP;AACD,WAHS,EAGP,MAAKD,YAHE,CAAV;AAID;AACF,OA5BM,CAAP;AA6BD;;AAED;AACA;;;;uBACGC,K,EAAOiB,Q,EAAU;AAClBT,4BAAYU,EAAZ,CAAelB,KAAf,EAAsB,UAACU,KAAD,EAAQL,YAAR,EAAsC;AAAA,2CAAbJ,QAAa;AAAbA,kBAAa;AAAA;;AAC1D;AACA;AACAC,2BAAQC,OAAR,GAAkBgB,IAAlB,CAAuB;AAAA,iBAAMF,0BAAYhB,QAAZ,CAAN;AAAA,SAAvB,EACGkB,IADH,CACQ,UAACC,OAAD,EAAa;AACjBZ,gCAAYO,IAAZ,CAAiBV,YAAjB,EAA+B,SAA/B,EAA0Ce,OAA1C;AACD,SAHH,EAIGC,KAJH,CAIS,UAACC,CAAD,EAAO;AACZd,gCAAYO,IAAZ,CAAiBV,YAAjB,EAA+B,SAA/B,EAA0C,8BAAeiB,CAAf,CAA1C;AACD,SANH;AAOD,OAVD;AAWD;;;wBAEGtB,K,EAAO;AACT,aAAOQ,sBAAYe,kBAAZ,CAA+BvB,KAA/B,CAAP;AACD;;;;;;AAGI,IAAMwB,kCAAa3B,kBAAnB;;AAEP,IAAM4B,aAAa,IAAI5B,kBAAJ,EAAnB;AACA4B,WAAWD,UAAX,GAAwB3B,kBAAxB;AACA4B,WAAW5B,kBAAX,GAAgCA,kBAAhC;;kBAEe4B,U;;AACfC,OAAOC,OAAP,GAAiBF,UAAjB","file":"renderer.js","sourcesContent":["import { ipcRenderer } from 'electron'; // eslint-disable-line\r\nimport uuid from 'uuid/v4';\r\nimport Promise from 'bluebird';\r\nimport serializeError from 'serialize-error';\r\n\r\nexport class PromiseIpcRenderer {\r\n  constructor(opts) {\r\n    if (opts) {\r\n      this.maxTimeoutMs = opts.maxTimeoutMs;\r\n    }\r\n  }\r\n\r\n  send(route, ...dataArgs) {\r\n    return new Promise((resolve, reject) => {\r\n      const replyChannel = `${route}#${uuid()}`;\r\n      let timeout;\r\n      let didTimeOut = false;\r\n\r\n      // ipcMain will send a message back to replyChannel when it finishes calculating\r\n      ipcRenderer.once(replyChannel, (event, status, returnData) => {\r\n        clearTimeout(timeout);\r\n        if (didTimeOut) {\r\n          return null;\r\n        }\r\n        switch (status) {\r\n          case 'success':\r\n            return resolve(returnData);\r\n          case 'failure':\r\n            return reject(returnData);\r\n          default:\r\n            return reject(new Error(`Unexpected IPC call status \"${status}\" in ${route}`));\r\n        }\r\n      });\r\n      ipcRenderer.send(route, replyChannel, ...dataArgs);\r\n\r\n      if (this.maxTimeoutMs) {\r\n        timeout = setTimeout(() => {\r\n          didTimeOut = true;\r\n          reject(new Error(`${route} timed out.`));\r\n        }, this.maxTimeoutMs);\r\n      }\r\n    });\r\n  }\r\n\r\n  // If I ever implement `off`, then this method will actually use `this`.\r\n  // eslint-disable-next-line class-methods-use-this\r\n  on(route, listener) {\r\n    ipcRenderer.on(route, (event, replyChannel, ...dataArgs) => {\r\n      // Chaining off of Promise.resolve() means that listener can return a promise, or return\r\n      // synchronously -- it can even throw. The end result will still be handled promise-like.\r\n      Promise.resolve().then(() => listener(...dataArgs))\r\n        .then((results) => {\r\n          ipcRenderer.send(replyChannel, 'success', results);\r\n        })\r\n        .catch((e) => {\r\n          ipcRenderer.send(replyChannel, 'failure', serializeError(e));\r\n        });\r\n    });\r\n  }\r\n  \r\n  off(route) {\r\n    return ipcRenderer.removeAllListeners(route);\r\n  }\r\n}\r\n\r\nexport const PromiseIpc = PromiseIpcRenderer;\r\n\r\nconst mainExport = new PromiseIpcRenderer();\r\nmainExport.PromiseIpc = PromiseIpcRenderer;\r\nmainExport.PromiseIpcRenderer = PromiseIpcRenderer;\r\n\r\nexport default mainExport;\r\nmodule.exports = mainExport;\r\n"]}
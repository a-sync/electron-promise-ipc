{"version":3,"sources":["../src/mainProcess.js"],"names":["PromiseIpcMain","opts","maxTimeoutMs","route","webContents","dataArgs","Promise","resolve","reject","replyChannel","timeout","didTimeOut","ipcMain","once","event","status","returnData","clearTimeout","Error","send","setTimeout","listener","on","then","results","sender","catch","e","removeAllListeners","PromiseIpc","mainExport","module","exports"],"mappings":";;;;;;;qjBAAoC;;;AAApC;;AACA;;;;AACA;;;;AACA;;;;;;;;IAEaA,c,WAAAA,c;AACX,0BAAYC,IAAZ,EAAkB;AAAA;;AAChB,QAAIA,IAAJ,EAAU;AACR,WAAKC,YAAL,GAAoBD,KAAKC,YAAzB;AACD;AACF;;AAED;;;;;yBACKC,K,EAAOC,W,EAA0B;AAAA,wCAAVC,QAAU;AAAVA,gBAAU;AAAA;;AAAA;;AACpC,aAAO,IAAIC,kBAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,YAAMC,eAAkBN,KAAlB,SAA2B,kBAAjC;AACA,YAAIO,gBAAJ;AACA,YAAIC,aAAa,KAAjB;;AAEA;AACAC,0BAAQC,IAAR,CAAaJ,YAAb,EAA2B,UAACK,KAAD,EAAQC,MAAR,EAAgBC,UAAhB,EAA+B;AACxDC,uBAAaP,OAAb;AACA,cAAIC,UAAJ,EAAgB;AACd,mBAAO,IAAP;AACD;AACD,kBAAQI,MAAR;AACE,iBAAK,SAAL;AACE,qBAAOR,QAAQS,UAAR,CAAP;AACF,iBAAK,SAAL;AACE,qBAAOR,OAAOQ,UAAP,CAAP;AACF;AACE,qBAAOR,OAAO,IAAIU,KAAJ,kCAAyCH,MAAzC,aAAuDZ,KAAvD,CAAP,CAAP;AANJ;AAQD,SAbD;AAcAC,oBAAYe,IAAZ,qBAAiBhB,KAAjB,EAAwBM,YAAxB,SAAyCJ,QAAzC;;AAEA,YAAI,MAAKH,YAAT,EAAuB;AACrBQ,oBAAUU,WAAW,YAAM;AACzBT,yBAAa,IAAb;AACAH,mBAAO,IAAIU,KAAJ,CAAaf,KAAb,iBAAP;AACD,WAHS,EAGP,MAAKD,YAHE,CAAV;AAID;AACF,OA5BM,CAAP;AA6BD;;AAED;AACA;;;;uBACGC,K,EAAOkB,Q,EAAU;AAClBT,wBAAQU,EAAR,CAAWnB,KAAX,EAAkB,UAACW,KAAD,EAAQL,YAAR,EAAsC;AAAA,2CAAbJ,QAAa;AAAbA,kBAAa;AAAA;;AACtD;AACA;AACAC,2BAAQC,OAAR,GAAkBgB,IAAlB,CAAuB;AAAA,iBAAMF,0BAAYhB,QAAZ,CAAN;AAAA,SAAvB,EACGkB,IADH,CACQ,UAACC,OAAD,EAAa;AACjBV,gBAAMW,MAAN,CAAaN,IAAb,CAAkBV,YAAlB,EAAgC,SAAhC,EAA2Ce,OAA3C;AACD,SAHH,EAIGE,KAJH,CAIS,UAACC,CAAD,EAAO;AACZb,gBAAMW,MAAN,CAAaN,IAAb,CAAkBV,YAAlB,EAAgC,SAAhC,EAA2C,8BAAekB,CAAf,CAA3C;AACD,SANH;AAOD,OAVD;AAWD;;;wBAEGxB,K,EAAO;AACT,aAAOS,kBAAQgB,kBAAR,CAA2BzB,KAA3B,CAAP;AACD;;;;;;AAGI,IAAM0B,kCAAa7B,cAAnB;;AAEP,IAAM8B,aAAa,IAAI9B,cAAJ,EAAnB;AACA8B,WAAWD,UAAX,GAAwB7B,cAAxB;AACA8B,WAAW9B,cAAX,GAA4BA,cAA5B;;kBAEe8B,U;;AACfC,OAAOC,OAAP,GAAiBF,UAAjB","file":"mainProcess.js","sourcesContent":["import { ipcMain } from 'electron'; // eslint-disable-line\r\nimport uuid from 'uuid/v4';\r\nimport Promise from 'bluebird';\r\nimport serializeError from 'serialize-error';\r\n\r\nexport class PromiseIpcMain {\r\n  constructor(opts) {\r\n    if (opts) {\r\n      this.maxTimeoutMs = opts.maxTimeoutMs;\r\n    }\r\n  }\r\n\r\n  // Send requires webContents -- see http://electron.atom.io/docs/api/ipc-main/\r\n  send(route, webContents, ...dataArgs) {\r\n    return new Promise((resolve, reject) => {\r\n      const replyChannel = `${route}#${uuid()}`;\r\n      let timeout;\r\n      let didTimeOut = false;\r\n\r\n      // ipcRenderer will send a message back to replyChannel when it finishes calculating\r\n      ipcMain.once(replyChannel, (event, status, returnData) => {\r\n        clearTimeout(timeout);\r\n        if (didTimeOut) {\r\n          return null;\r\n        }\r\n        switch (status) {\r\n          case 'success':\r\n            return resolve(returnData);\r\n          case 'failure':\r\n            return reject(returnData);\r\n          default:\r\n            return reject(new Error(`Unexpected IPC call status \"${status}\" in ${route}`));\r\n        }\r\n      });\r\n      webContents.send(route, replyChannel, ...dataArgs);\r\n\r\n      if (this.maxTimeoutMs) {\r\n        timeout = setTimeout(() => {\r\n          didTimeOut = true;\r\n          reject(new Error(`${route} timed out.`));\r\n        }, this.maxTimeoutMs);\r\n      }\r\n    });\r\n  }\r\n\r\n  // If I ever implement `off`, then this method will actually use `this`.\r\n  // eslint-disable-next-line class-methods-use-this\r\n  on(route, listener) {\r\n    ipcMain.on(route, (event, replyChannel, ...dataArgs) => {\r\n      // Chaining off of Promise.resolve() means that listener can return a promise, or return\r\n      // synchronously -- it can even throw. The end result will still be handled promise-like.\r\n      Promise.resolve().then(() => listener(...dataArgs))\r\n        .then((results) => {\r\n          event.sender.send(replyChannel, 'success', results);\r\n        })\r\n        .catch((e) => {\r\n          event.sender.send(replyChannel, 'failure', serializeError(e));\r\n        });\r\n    });\r\n  }\r\n\r\n  off(route) {\r\n    return ipcMain.removeAllListeners(route);\r\n  }\r\n}\r\n\r\nexport const PromiseIpc = PromiseIpcMain;\r\n\r\nconst mainExport = new PromiseIpcMain();\r\nmainExport.PromiseIpc = PromiseIpcMain;\r\nmainExport.PromiseIpcMain = PromiseIpcMain;\r\n\r\nexport default mainExport;\r\nmodule.exports = mainExport;\r\n"]}